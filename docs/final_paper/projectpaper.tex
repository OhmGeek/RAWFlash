\documentclass[12pt,a4paper]{article}
\usepackage{times}
\usepackage{durhampaper}
\usepackage{harvard}
\citationmode{abbr}
\bibliographystyle{agsm}

\title{RAWFlash: A cloud based RAW image editor}
\author{} % leave; your name goes into \student{}
\student{Ryan Collins}
\supervisor{Dr Tom Friedetzky}
\degree{[MEng Computer Science]}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
% These instructions give you guidelines for preparing the final paper.  DO NOT change any settings, such as margins and font sizes.  Just use this as a template and modify the contents into your final paper.  Do not cite references in the abstract.

% The abstract must be a Structured Abstract with the headings {\bf Context/Background}, {\bf Aims}, {\bf Method}, {\bf Results}, and {\bf Conclusions}.  This section should not be longer than half of a page, and having no more than one or two sentences under each heading is advised.
\paragraph{Context/Background}
RAW images are used by photographers to improve the quality of their images, specifically when editing. With JPEG files, the loss of 
data from compression leads to poorer quality edits, while using RAW results in a higher dynamic range. The editing of these files is 
traditionally done on a high-spec machine, capable of processing images with large resolutions. In the field, this can be difficult. 
When used for websites, the standard process involves editing a RAW file locally and exporting it, uploading the exported image to a 
Content Management System (CMS). Here, the CMS will then edit the file again, resizing the image to ensure it displays properly on the
browser.

\paragraph{Aims}
The main aim of this project is to test the feasibility of a Cloud-based RAW image editor, allowing image adjustments such as exposure 
adjustment, colour adjustment, and overall improvements to the quality of the image, all within a cloud application rather than on the 
desktop.

\paragraph{Method}
A render server back-end will first be implemented as an API, taking in an input as a JSON object, and then processing the image, and 
then a JavaScript client shall be created to interface with this API.

\paragraph{Results}

\paragraph{Conclusions}

\end{abstract}

\begin{keywords}
RAW image editing, dcraw, cloud image editing, docker, image processing
\end{keywords}

\section{Introduction}
% What is the project about?
The project itself concerns itself with editing RAW files through a system deployable to the cloud
so that it can both be used by people editing photos, as well as by extension by other systems. While RAW
editing isn't new, the creation of a system to edit RAW files would give users more control in content management,
and produce better quality images.


\subsection{RAW Files Explained}
RAW isn't a file format in itself, but rather an umbrella term for a set of many different formats that store the
raw camera sensor data. There are a set of different proprietary file formats, that all store similar information,
but in different ways. 

When an image is captured, the camera sensor uses charge buildup to represent the amount of light that is incident on the sensor
(using a phenomenon known as the photoelectric effect). Colour data itself isn't stored at all in the RAW image. Colour is achieved
by putting a filter over the sensor, such that each individual part of the sensor captures only red, green or blue light, which then
allows one to build up a full colour image. The process of creating a full colour image from the camera sensor is called demosaicing. 


There are several different steps to decoding RAW images, in addition to demosaicing which was explained above. These are:

\paragraph{White Balance}


\paragraph{Gamma Correction}
Cameras typically represent colour changes linearly, with a gamma of 1.0. \textbf{TODO FIND SOURCE OTHER THAN CURRENt}.
However, this isn't necessarily pleasing to the eye, so this can be changed to change how tones are reflected. For example, this can 

\paragraph{Sharpening/Noise Reduction}
Sometimes, noise can creep into the image, particularly if the image itself is shot with large ISO levels (ISO is a sensitivity setting that can be
set when taking a photo, to allow the camera sensor to be more sensitive to light \textbf{TODO FIND SOURCE FOR ISO DEFINITION}). This can be corrected
during the editing process.

Also, sometimes edges might need to be enhanced to bring out the detail in the image. This can again be used for stylistic purposes, but this is ultimately the
decision of the image editor.

\subsubsection{Comparison to JPEG}
JPEG, a common format in the consumer photography market, often has smaller files due to JPEG compression.
While this can be good to minimize the amount of memory used, the lossy compression is problematic as adjusting tone
and colour information as JPEG heavily compresses colours (so minor adjustments in colour will appear as the same colour in JPEG).
When shooting an image with JPEG, the camera uses a built-in RAW processor to automatically process the RAW data, perhaps using some settings
that can be adjusted in the camera, and compresses the image down into a JPEG format.

On the other hand, RAW allows one to have far more control over the final image, by adjusting various settings with a far greater freedom and by using the camera's
built in processing.

\cite{UnderstandingRAWCapture}

\subsection{Applications of RAW Image Editing}
\subsubsection{Content Management}
When using Content Management Systems (CMS) with websites, some element of image processing is usually carried out.

When working with better quality RAW images, usually these RAW files are edited locally, exported in some format, and then
uploaded to the Content Management System. From here, this exported image is then processed and various images are produced,
typically with different sizes and sometimes different focal points (with the image cropped around certain objects/locations).

However, a RAW based image editor would allow one to make this process more concise by uploading the RAW file, editing it from within
the Content Management System, and using the RAW file and defined operations (along with the size instructions supplied from the various
templates/webpages) to produce individual images for each page on the website. This removes the need for purchasing expensive RAW editing software,
allowing the user to focus on creating excellent content, rather than spending time producing outstanding images with potentially complex software.

\subsection{Problems with Current Implementations}
Most current implementations exist as native applications, designed specifically for one or several different platforms.
With this, a specific machine shall have the program installed, and shall contain all the features from managing files, to
rendering images, to displaying the output to the user as required. 

However, larger images can require a larger amount of resources to render properly, and furthermore if one intends on editing RAW images
on the go, transporting a larger machine isn't convenient. Furthermore, the RAW editing software might not necessarily be available on the platform
that is nearest to the user. 

Instead of this approach, this project is taking an approach of having a Cloud system that can render images, which can scale if necessary by adding more
servers, so whatever client device is used, raw images can be edited providing the user has an internet connection (which with the recent presence of 3G and 4G,
they are likely to have).

Furthermore, due to the proprietary nature of most RAW processing applications, using them as a component in another system becomes very difficult,
and by creating a system that can be controlled by other external systems can provide RAW image editing as a service.

\subsection{Project Objectives}
The project objectives can be expressed as Minimum, Intermediate and Advanced Objectives
% Develop a Cloud-based RAW Image Photo Editor. 


\paragraph{Minimum Objectives}
    \begin{itemize}
      \item Exposure adjustment
      \item Noise reduction methods (Gaussian, mean)
      \item Web Interface interacting with an image processing server
      \item Non-destructive image adjustment (i.e. no reduction in quality over time)
    \end{itemize}
\paragraph{Intermediate Objectives}
    \begin{itemize}
      \item Load DNG RAW files by upload
      \item White Balance Adjustment
      \item Gamma Correction
      \item Modern, user friendly User Experience
      \item Cropping, Rotating and Exporting to other formats
    \end{itemize}
\paragraph{Advanced Objectives}
    \begin{itemize}
      \item Addressing potential scalability issues
      \item Haze removal
      \item Sharpening
    \end{itemize}
\section{Related Work}
% This section presents a survey of existing work on the problems that this project addresses.  it should be between 2 to 4 pages in length.  The rest of this section shows the formats of subsections as well as some general formatting information for tables, figures, references and equations.


\subsection{RAW files, and parsing}
% DNG standard
% 

As explained in the introduction, there are many different types of proprietary RAW file formats, such as Canon's CRW and CR2, and Nikon's NEF among others.
Each of these formats stores similar information, but in a different way.

Adobe created and made public their standard RAW file format called DNG. It is defined as "a non-proprietary file format for storing camera raw files that
can be used by a wide range of hardware and software vendors" by Adobe in the specification. \cite{DNGSpec}

The DNG format 

\textbf{TODO: ADD DNG SPEC TO BIBTEX FILE}
\subsection{Existing Solutions}
% Lightroom, proprietary
% Darktable, RAW Therapee
% DCRAW, LibRAW
% ImageMagick => not as useful for RAW though.

    \paragraph{Adobe Lightroom}
    Adobe Lightroom is a native and proprietary tool, developed by Adobe, for editing images, both RAW images, and otherwise.
    RAW processing in Lightroom is done by Adobe Camera RAW (as Lightroom builds on this useful tool), 

\subsection{}


\section{Solution}

% This section presents the solutions to the problems in detail.  The design and implementation details should all be placed in this section.  You may create a number of subsections, each focussing on one issue.  

% This section should be between 4 to 7 pages in length.

\subsection{Client-Server Communication Protocol}
% SocketIO
% REST
% benefits
% transferring images: TIFF, PNG, base64 vs file based.
% compatibility.
In order to communicate between the client side interface (where the user provides inputs and instructions
for rendering images) to the server side (the entrance of the rendering system, which manages jobs), we need
a method for transmitting the correct information in an appropriate manner.

\subsubsection{Communication Methods}
\paragraph{Representational State Transfer (REST)}
The REST method uses URL routes to send/retrieve information, using HTTP methods such as
GET, POST, PUT, DELETE.

\paragraph{Web Socket}
Web Socket is a new technology that allows easy two-way communication between client and server, rather like how
sockets work within normal network programming. The client would send a message to the server with the required
render instructions, and when the job is complete, the server would return the result to the user. Listeners on both
sides wait for messages to be received, and process the messages in the appropriate manner.

This lends itself quite well to our method, as with the user constantly changing settings and requesting a render (to
view the preview), and repreating the process as settings are adjusted, two way communication seems far more approriate
for this application.

However, Web Socket does have downsides. As a fairly new technology, it's not universally supported, and only modern browsers
support the protocol, and potentially some firewalls might block ports required, and some hosting providers might not support 
it either. Therefore, while websocket is ideal, compatibility might be a problem.

\paragraph{Socket.IO}
Socket.io itself isn't really a protocol, but an implementation of both REST and Websocket, designed for event driven
applications. Where websocket is supported, it is used, but where websocket isn't supported, the system falls back to
REST to transmit and receive data through polling. Implementation wise, the system is built in an event driven way,
with message handlers being written, and the framework deals with the edge cases with compatibility.

However, a problem arises with this, as this is only fully supported in a limited number of languages, namely JavaScript (both client
and server side), and unofficial support is available for Java. Therefore, JavaScript shall be used for the client side (which is really the only
option anyway), and Java for the server side, due to the Image library provided.

This is the solution I've decided to use.

\subsection{Rendering Server Structure}
% Layers
% Adams processor vs DCRAW
% Message Queue vs full Socket IO (drawbacks of using SocketIO on its own)
% Implementing gamma correction (algorithms used)
% Implementing Colour adjustments (algorithms used)

\subsection{Adams Processor}
\subsubsection{Gamma Correction}
% Impmenetation
% formula
% lookup table
The process of gamma correction involves taking the RAW image, which by default has a linear tone curve (gamma of 1.0), and
mapping the colours to a different tone curve.

The function $f$ is used as a transformation from the image, to the gamma correction image. $f$ is defined as:

$$f(\gamma, v) = 255 \cdot (\frac{v}{255})^{\gamma}$$

In the above definition, v is the brightness value of one cell of the image, where $0 <= v <= 255$.

On the implementation level, the best approach is to use a Lookup Table, with an input of the RAW image components (in our case, Red, Green and Blue),
and an output of the adjusted component values in accordance with the gamma correction function. The benefit of using a lookup table, rather than calculating
the gamma value for every single possible value, is that one doesn't need to calculate the same piece of data more than once (as bright regions, or dark regions might
potentially have the same input values). 

\textbf{TODO: DIAGRAM SHOWING WORKFLOW OF THE LUT VS CALCUATING FUNCTION}
\subsubsection{Noise Reduction}
% Gaussian vs Mean
% Kernel Size
% Details
\subsubsection{Unsharp Image Adjustment}
    % Mean vs Gaussian
    % algorithm for doing this
    % implementation

\subsubsection{White Balance Adjustment}

\subsubsection{Colour Adjustment}
    % Based on gains
    % control RGB components.
    % each one has multipliers



\subsection{Web Editor Functionality}
% While render server does all the rendering, basic functionality of an editor should be present in the example
% cloud editor, for  testing.

% Implementing an Undo system: algorithms, data storage.
% User interface: sidebar with less cluttered nature.

\subsection{Storing User Images}
% While editing individual images is ok, editing a selection of
% images would be more functional, allowing us to select server uploaded
% images, edit them, and export them.
While one can edit individual images by simply supplying them to the editor, they need to be accessed somehow,
preferably through supplying some URL, where the RAW image can be downloaded, and then used to edit an image.
The system shall be built to be as customizable as possible, by downloading images from a supplied URL in the request,
and this RAW image is downloaded (or cached to the render server), wherever the file itself is hosted. This way, we can
either supply a system for uploading/storing images, or the user can choose to use an image store elsewhere such as Amazon
S3, OpenStack Swift, or other storage backend. Our system simply uses the Django file system, which stores the file in an
uploads folder on disk.



\subsection{Managing a big system}
% Docker/DockerCOmpose for managing a massive distributed system.
% Docker automatic restart on error 
As our system design calls for a large number of individual components, managing all of these together can be quite complex.

One option is to write a script that deals with the setup of each individual component: web server, web services, render dispatcher, render servers (however many we need),
and message queue. However, if a component of the system stops working, that'll bring down the system entirely, and writing a script won't necessarily allow us to deploy the system
across several different machines.

Our solution to this problem is to use Docker. Each component in the system shall be given its own individual container (essentially a virtual machine), where
it is sandboxed to ensure that systems don't interfere with one another, and each container is networked together. Rather than manually setting up the networking,
one can use Docker Compose to automatically deal with the links between different containers, to ensure that private links between containers are set up, but these links
can't be accessed from outside the system. This method is preferable, as then one cannot access the message queue/other sensitive components directly. That way, only by sending
the proper request, will the system respond with an output.

\textbf{TODO: INSERT IMAGE OF ARCHITECTURE HERE}
\textbf{TODO: DOCKER SOURCE }
\subsection{Unit Testing Issues with Image Processing}
% Can't just expect a given output, because each algorithm may change the image in a different way,
% and in some cases we are using floating point to do image adjustments. This causes some error, and therefore
% we won't necessarily get exactly the same image out.

For one to compare the output of the system with other RAW editors is not necessarily as easy as bitwise ANDing the files, and finding the percentage
differences. While this might work if all systems use the same algorithms to do the same tasks, due to the proprietary nature of RAW image editing,
different implementations of demosaicing exist, yielding slightly different images, along with potential different ways of adopting equalization,
gamma correction and various other colour adjustments (for example, we use RGB gain to adjust the colours, while LightRoom instead uses Chromacity).
It'll be difficult to use the same settings for every single system. Instead, it might be better to edit a variety of different images, and compare them
by eye, to determine whether the algorithm itself is working correctly, and using base cases to test the output of a system by eye.

Base cases include:

Using a gamma of zero will yield a completely white image. Uisng a gamma of 1 will yield the input image, for gamma correction.
Setting red gain to 1, and all others to zero will yield an image with only the red channel. Doing the same for green and blue should reveal the same.
This will ensure the algoritm is working correctly.

Exposure zero should yield a completely black image. Using a very high exposure should yield a completely, or nearly white image.

We can test undo and redo trivially.
\section{Results}

% this section presents the results of the solutions.  It should include information on experimental settings.  The results should demonstrate the claimed benefits/disadvantages of the proposed solutions.

% This section should be between 2 to 3 pages in length.

\subsection{Comparison With Other Editors}
Testing the system against Lightroom, Darktable and RawTherapee,
testing the image output compared to these, and also performance
based tests compared with traditional native software.

TODO: Mention specs of the machine.


\subsection{User Testing}
Get User Comments on system

\subsection{}

\section{Evaluation}

% This section should between 1 to 2 pages in length.

\subsection{Application to Web Content Management Systems}
% Process of editing and uploading images
% RAW -> JPEG -> Upload -> Further compression/adjustments in CMS for web -> Output
% better to skip intermediate steps, meaning less computational effort on one end, less cost for
% expensive software.

\subsection{Benefits of Portable Image Editing}
% Allows one to edit images whatever the location,

\subsection{Performance Issues and Improvements}
% Improvement by use of multithreading for image processing
% Java's build in Image Manipulation has a number of undocumented bugs.
% Using GPU might improve performance furhter.


\section{Conclusions}

This section summarises the main points of this paper.  Do not replicate the abstract as the conclusion.  A conclusion might elaborate on the importance of the work or suggest applications and extensions.  This section should be no more than 1 page in length.

The page lengths given for each section are indicative and will vary from project to project but should not exceed the upper limit.  A summary is shown in Table \ref{summary}.

\begin{table}[htb]
\centering
\caption{SUMMARY OF PAGE LENGTHS FOR SECTIONS}
\vspace*{6pt}
\label{summary}
\begin{tabular}{|ll|c|} \hline
& \multicolumn{1}{c|}{\bf Section} & {\bf Number of Pages} \\ \hline
I. & Introduction & 2--3 \\ \hline
II. & Related Work & 2--3 \\ \hline
III. & Solution & 4--7 \\ \hline
IV. & Results & 2--3 \\ \hline
V. & Evaluation & 1-2 \\ \hline
VI. & Conclusions & 1 \\ \hline
\end{tabular}
\end{table}


\bibliography{projectpaper}


\end{document}